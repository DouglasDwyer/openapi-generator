// {{classname}} - {{{description}}}{{^description}}struct for {{{classname}}}{{/description}}
type {{classname}} struct {
	{{#oneOf}}
	{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} *{{{.}}}
	{{/oneOf}}
}

{{#oneOf}}
// {{{.}}}As{{classname}} is a convenience function that returns {{{.}}} wrapped in {{classname}}
func {{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}}As{{classname}}(v *{{{.}}}) {{classname}} {
	return {{classname}}{
		{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}}: v,
	}
}

{{/oneOf}}


{{#allVars}}
{{#required}}
// Get{{name}} returns the {{name}} field value
{{#isNullable}}
// If the value is explicit nil, the zero value for {{vendorExtensions.x-go-base-type}} will be returned
{{/isNullable}}
{{#deprecated}}
// Deprecated
{{/deprecated}}
func (o *{{classname}}) Get{{name}}() {{vendorExtensions.x-go-base-type}} {
	type getResult interface {
		Get{{name}}() {{vendorExtensions.x-go-base-type}}
	}

	return o.GetActualInstance().(getResult).Get{{name}}()
}

// Get{{name}}Ok returns a tuple with the {{name}} field value
// and a boolean to check if the value has been set.
{{#isNullable}}
// NOTE: If the value is an explicit nil, `nil, true` will be returned
{{/isNullable}}
{{#deprecated}}
// Deprecated
{{/deprecated}}
func (o *{{classname}}) Get{{name}}Ok() ({{^isArray}}{{^isFreeFormObject}}*{{/isFreeFormObject}}{{/isArray}}{{vendorExtensions.x-go-base-type}}, bool) {
	type getResult interface {
		Get{{name}}Ok() ({{^isArray}}{{^isFreeFormObject}}*{{/isFreeFormObject}}{{/isArray}}{{vendorExtensions.x-go-base-type}}, bool)
	}

	return o.GetActualInstance().(getResult).Get{{name}}Ok()
}

// Set{{name}} sets field value
{{#deprecated}}
// Deprecated
{{/deprecated}}
func (o *{{classname}}) Set{{name}}(v {{vendorExtensions.x-go-base-type}}) {
	type getResult interface {
		Set{{name}}(v {{vendorExtensions.x-go-base-type}})
	}

	o.GetActualInstance().(getResult).Set{{name}}(v)
}

{{/required}}
{{^required}}
// Get{{name}} returns the {{name}} field value if set, zero value otherwise{{#isNullable}} (both if not set or set to explicit null){{/isNullable}}.
{{#deprecated}}
// Deprecated
{{/deprecated}}
func (o *{{classname}}) Get{{name}}() {{vendorExtensions.x-go-base-type}} {
	type getResult interface {
		Get{{name}}() {{vendorExtensions.x-go-base-type}}
	}

	return o.GetActualInstance().(getResult).Get{{name}}()
}

// Get{{name}}Ok returns a tuple with the {{name}} field value if set, nil otherwise
// and a boolean to check if the value has been set.
{{#isNullable}}
// NOTE: If the value is an explicit nil, `nil, true` will be returned
{{/isNullable}}
{{#deprecated}}
// Deprecated
{{/deprecated}}
func (o *{{classname}}) Get{{name}}Ok() ({{^isArray}}{{^isFreeFormObject}}*{{/isFreeFormObject}}{{/isArray}}{{vendorExtensions.x-go-base-type}}, bool) {
	type getResult interface {
		Get{{name}}Ok() ({{^isArray}}{{^isFreeFormObject}}*{{/isFreeFormObject}}{{/isArray}}{{vendorExtensions.x-go-base-type}}, bool)
	}

	return o.GetActualInstance().(getResult).Get{{name}}Ok()
}

// Has{{name}} returns a boolean if a field has been set.
func (o *{{classname}}) Has{{name}}() bool {
	type getResult interface {
		Has{{name}}() bool
	}

	return o.GetActualInstance().(getResult).Has{{name}}()
}

// Set{{name}} gets a reference to the given {{dataType}} and assigns it to the {{name}} field.
{{#deprecated}}
// Deprecated
{{/deprecated}}
func (o *{{classname}}) Set{{name}}(v {{vendorExtensions.x-go-base-type}}) {
	type getResult interface {
		Set{{name}}(v {{vendorExtensions.x-go-base-type}})
	}

	o.GetActualInstance().(getResult).Set{{name}}(v)
}
{{#isNullable}}
{{^vendorExtensions.x-golang-is-container}}
// Set{{name}}Nil sets the value for {{name}} to be an explicit nil
func (o *{{classname}}) Set{{name}}Nil() {
	type getResult interface {
		Set{{name}}Nil()
	}

	o.GetActualInstance().(getResult).Set{{name}}Nil()
}

// Unset{{name}} ensures that no value is present for {{name}}, not even an explicit nil
func (o *{{classname}}) Unset{{name}}() {
	type getResult interface {
		Unset{{name}}()
	}

	o.GetActualInstance().(getResult).Unset{{name}}()
}
{{/vendorExtensions.x-golang-is-container}}
{{/isNullable}}

{{/required}}
{{/allVars}}

// Unmarshal JSON data into one of the pointers in the struct
func (dst *{{classname}}) UnmarshalJSON(data []byte) error {
	var err error
	{{#isNullable}}
	// this object is nullable so check if the payload is null or empty string
	if string(data) == "" || string(data) == "{}" {
		return nil
	}

	{{/isNullable}}
	{{#useOneOfDiscriminatorLookup}}
	{{#discriminator}}
	{{#mappedModels}}
	{{#-first}}
	// use discriminator value to speed up the lookup
	var jsonDict map[string]interface{}
	err = newStrictDecoder(data).Decode(&jsonDict)
	if err != nil {
		return fmt.Errorf("Failed to unmarshal JSON into map for the discriminator lookup.")
	}

	{{/-first}}
	// check if the discriminator value is '{{{mappingName}}}'
	if jsonDict["{{{propertyBaseName}}}"] == "{{{mappingName}}}" {
		// try to unmarshal JSON data into {{{modelName}}}
		err = json.Unmarshal(data, &dst.{{{modelName}}})
		if err == nil {
			return nil // data stored in dst.{{{modelName}}}, return on the first match
		} else {
			dst.{{{modelName}}} = nil
			return fmt.Errorf("Failed to unmarshal {{classname}} as {{{modelName}}}: %s", err.Error())
		}
	}

	{{/mappedModels}}
	return nil
	{{/discriminator}}
	{{^discriminator}}
        match := 0
        {{#oneOf}}
        // try to unmarshal data into {{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}}
        err = json.Unmarshal(data, &dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}})
        if err == nil {
                json{{{.}}}, _ := json.Marshal(dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}})
                if string(json{{{.}}}) == "{}" { // empty struct
                        dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} = nil
                } else {
                        match++
                }
        } else {
                dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} = nil
        }

        {{/oneOf}}
        if match > 1 { // more than 1 match
                // reset to nil
                {{#oneOf}}
                dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} = nil
                {{/oneOf}}

                return fmt.Errorf("Data matches more than one schema in oneOf({{classname}})")
        } else if match == 1 {
                return nil // exactly one match
        } else { // no match
                return fmt.Errorf("Data failed to match schemas in oneOf({{classname}})")
        }
	{{/discriminator}}
	{{/useOneOfDiscriminatorLookup}}
	{{^useOneOfDiscriminatorLookup}}
	match := 0
	{{#oneOf}}
	// try to unmarshal data into {{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}}
	err = newStrictDecoder(data).Decode(&dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}})
	if err == nil {
		json{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}}, _ := json.Marshal(dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}})
		if string(json{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}}) == "{}" { // empty struct
			dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} = nil
		} else {
			match++
		}
	} else {
		dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} = nil
	}

	{{/oneOf}}
	if match > 1 { // more than 1 match
		// reset to nil
		{{#oneOf}}
		dst.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} = nil
		{{/oneOf}}

		return fmt.Errorf("Data matches more than one schema in oneOf({{classname}})")
	} else if match == 1 {
		return nil // exactly one match
	} else { // no match
		return fmt.Errorf("Data failed to match schemas in oneOf({{classname}})")
	}
	{{/useOneOfDiscriminatorLookup}}
}

// Marshal data from the first non-nil pointers in the struct to JSON
func (src {{classname}}) MarshalJSON() ([]byte, error) {
{{#oneOf}}
	if src.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} != nil {
		return json.Marshal(&src.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}})
	}

{{/oneOf}}
	return nil, nil // no data in oneOf schemas
}

// Get the actual instance
func (obj *{{classname}}) GetActualInstance() (interface{}) {
	if obj == nil {
		return nil
	}
{{#oneOf}}
	if obj.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}} != nil {
		return obj.{{#lambda.type-to-name}}{{{.}}}{{/lambda.type-to-name}}
	}

{{/oneOf}}
	// all schemas are nil
	return nil
}

{{>nullable_model}}
